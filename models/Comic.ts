// A callback function is passed in as a parameter for every method to make operations in mongoose synchronous

export class Comic {

    // class variables
    mongoose: any;
    schema: any;
    comicSchema: any;
    static comic: any = null; // static class variable

    // intializing a comic object establishes a DB connection
    constructor(mongoose:any) {
        this.mongoose = mongoose;
        this.schema = this.mongoose.Schema;
        
        // define Comic Object schema for storing Comic data fields
        this.comicSchema = new this.schema({  // NOTE* comicID is implicity generated by DB service at time of document creation (attribute is "_id")
            title: String,
            normalized_title: String,
            authorID: String,
            authorUsername: String,
            normalized_authorUsername: String,
            publicationDate: Date,
            description: String,
            genre: String,
            toPublish: Boolean
        });

        if (Comic.comic == null) { // ensure model is only initialized once
            Comic.comic = this.mongoose.model('Comic', this.comicSchema);
        }
    }

    // INSERT 
    // an _id that we use as ComicID is auto-generated when we insert a new comic object into the DB.
    // NOTE: "un" stands for unnormalized
    insert(_title: String, _authorID: String, _authorUsername: String, _description: String, _genre: String, _toPublish: Boolean, callback: Function): any {
        var db = this.mongoose.connection;

        var _publicationDate = null;

        if (_toPublish == true)
                _publicationDate = new Date();
       
        // create a new comic object with the client given data fields
        var c = new Comic.comic({
            title: _title,
            normalized_title: _title.toLowerCase(),
            authorID: _authorID,
            authorUsername: _authorUsername,
            normalized_authorUsername: _authorUsername.toLowerCase(),
            publicationDate: _publicationDate,
            description: _description,
            genre: _genre,
            toPublish: _toPublish
        });
        
        // insert the new comic obj into the DB
        c.save(function (err, doc) {
            if (err)
                return console.error(err);
            // pass back the ComicID after the save function is done executing
            callback(doc._id.toString());
        });
    }

    // GET 
    // we use the comicID to retrieve a comic from the DB
    get(_comicID: String, callback: Function): any {
        var db = this.mongoose.connection;
        var comicModel = Comic.comic;
       
        comicModel.findById({ _id: _comicID }, function (err, doc) {
            if (err)
                return console.error(err);
            // pass back the retrieved comic object to the client
            callback(doc);
        });

    }

    // GETALL 
    // we get every comic record in the collection
    getAll(callback: Function): any {
        var db = this.mongoose.connection;
        var comicModel = Comic.comic;

        comicModel.find({}, function (err, docs) {
            if (err)
                return console.error(err);
            callback(docs);
        });
    }

    // UPDATE 
    update(_comicID: String, _title: String, _authorID: String, _authorUsername: String, _publicationDate: Date, _description: String, _genre: String, _toPublish: Boolean, callback: Function): void {
        var db = this.mongoose.connection;
        var comicModel = Comic.comic;

        var usablePublicationDate = _publicationDate;
        if (_toPublish == true) // set publication date to the date of now if comic is edited and set to be published
            usablePublicationDate = new Date();

        var a_comic = new Comic.comic({
            title: _title,
            normalized_title: _title.toLowerCase(),
            authorID: _authorID,
            authorUsername: _authorUsername,
            normalized_authorUsername: _authorUsername.toLowerCase(),
            publicationDate: usablePublicationDate,
            description: _description,
            genre: _genre,
            toPublish: _toPublish
        });

        var comicData = a_comic.toObject();

        delete comicData._id; // rid of mongoose error of updating id
   
        comicModel.update({ _id: _comicID }, comicData, { multi: false }, function (err, doc) {
            if (err)
                return console.error(err);
            callback();
        });

    }

    
    // DELETE 
    delete(_comicID: String, _contributorID: String, callback: Function): void {
        var db = this.mongoose.connection;
        var comicModel = Comic.comic;
      
        // retrieve the authorID of the comic.
        comicModel.findById({ _id: _comicID }, function (err, doc) {
            if (err)
                return console.error(err);
            var authorID = doc.authorID;
                   
            // can delete only if the contributor is the OWNER of the COMIC
            if (_contributorID == authorID) {
                comicModel.remove({ _id: _comicID }, function (err, doc) {
                    if (err)
                        return console.error(err);
                    callback();
                });
            } else {
                console.log("User not authorized to delete comic cells.");
            }
        });
    }

    getComicsSortedByTitle(callback: Function): any {
        var db = this.mongoose.connection;
        var comicModel = Comic.comic;

        // use normalized_title field of comic model to get alphabetically sorted titles 
        comicModel.aggregate([
            { $sort: { normalized_title: 1 } }
        ], function (err, docs) {
            return docs
        });
    }

    getComicsSortedByAuthor(callback: Function): any {
        var db = this.mongoose.connection;
        var comicModel = Comic.comic;

        // use normalized_author field of comic model to get alphabetically sorted authors 
        comicModel.aggregate([
            { $sort: { normalized_author: 1 } }
        ], function (err, docs) {
            return docs
        });
    }

    getComicsSortedByMostRecentlyPublished(callback: Function): any {
        var db = this.mongoose.connection;
        var comicModel = Comic.comic;

        comicModel.aggregate([
            { $sort: { publicationDate: -1 } }
        ], function (err, docs) {
            return docs
        });
    }

    getComicsSortedByLeastRecentlyPublished(callback: Function): any {
        var db = this.mongoose.connection;
        var comicModel = Comic.comic;

        comicModel.aggregate([
            { $sort: { publicationDate: 1 } }
        ], function (err, docs) {
            return docs
        });
    }
}
