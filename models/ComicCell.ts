// A callback function is passed in as a parameter for every method to make operations in mongoose synchronous

export class ComicCell {

    
    // class variables
    mongoose: any;
    schema: any;
    comicCellSchema: any;
    static comicCell: any = null; // static class variable

    // intializing a comicCell object establishes a DB connection
    constructor(mongoose: any) {
        this.mongoose = mongoose;
        this.schema = this.mongoose.Schema;

        // define ComicCell Object schema for storing Comic data fields
        this.comicCellSchema = new this.schema({  // NOTE* comicCellID is implicity generated by DB service at time of document creation (attribute is "_id")
            comicID: String, // the Comic that the image or "cell" is associated with
            ownerID: String, // NOTE* OWNER of the COMIC can delete all associated comic cells
            collaboratorID: String, // NOTE* COLLABORATOR TO the COMIC can own delete cells he/she created
            toPublish: Boolean
        });

        if (ComicCell.comicCell == null) { // ensure model is only initialized once
            ComicCell.comicCell = this.mongoose.model('ComicCell', this.comicCellSchema);
        }
    }

    // INSERT 
    // an _id that we use as ComicID is auto-generated when we insert a new comic object into the DB
    // we pass this id back to the client
    insert(_comicID: String, _ownerID: String, _collaboratorID: String, _toPublish: Boolean, callback: Function): any {
        var db = this.mongoose.connection;

        // create a new comicCell object with the client-given data fields
        var cc = new ComicCell.comicCell({
            comicID: _comicID,
            ownerID: _ownerID,  // ownerID and collaboratorID = owner ID and collaborator ID
            collaboratorID: _collaboratorID,
            toPublish: _toPublish
        });
        
        // insert the new comic obj into the DB
        cc.save(function (err, doc) {
            if (err)
                return console.error(err);
            // pass back the ComicID after the save function is done executing
            callback(doc._id.toString());
        });
    }

    // GET ONE comicCell by quering by cell's ID 
    get(_comicCellID: String, callback: Function): any {
        var db = this.mongoose.connection;
        var comicCellModel = ComicCell.comicCell;

        // find all the comicCells associated with a single comicID
        comicCellModel.findById({ _id: _comicCellID }, function (err, doc) {
            if (err)
                return console.error(err);
            // pass back the retrieved comic cell object to the client
            callback(doc);
        });

    }

    // GET ONE comicCell by quering by cell's ID 
    getRepresentative(_comicID: String, callback: Function): any {
        var db = this.mongoose.connection;
        var comicCellModel = ComicCell.comicCell;

        // find all the comicCells associated with a single comicID
        comicCellModel.findOne({ comicID: _comicID.toString() }, function (err, doc) {
            if (err)
                return console.error(err);
            // pass back the retrieved comic cell object to the client
            callback(doc);
        });
    }

    // GET all comicCells associated with a comic 
    getAll(_comicID: String, callback: Function): any {
        var db = this.mongoose.connection;
        var comicCellModel = ComicCell.comicCell;

        // find all the comicCells associated with a single comicID
        comicCellModel.find({ 'comicID': _comicID }, function (err, docs) {
            if (err)
                return console.error(err);
            // pass back the retrieved comic object to the client
            callback(docs);
        });

    }

    // DELETE one comic cell 
    delete(_comicCellID: String, _contributorID: String, callback: Function): void {
        var db = this.mongoose.connection;
        var comicCellModel = ComicCell.comicCell;

        comicCellModel.findById({ _id: _comicCellID }, function (err, doc) {
            if (err)
                return console.error(err);
            var ownerID = doc.ownerID;
            var collaboratorID = doc.collaboratorID;
        
            // can delete only if the contributor is either the OWNER of the COMIC or a COLLABORATOR who owns the COMICCELL
            if (_contributorID == ownerID || _contributorID == collaboratorID) {
                comicCellModel.remove({ _id: _comicCellID }, function (err, doc) {
                    if (err)
                        return console.error(err);
                    callback();
                });
            } else {
                console.log("User not authorized to delete comic cell.");
            }
        });
    }

    // DELETE ALL comic cells associated with the same comic 
    deleteAll(_comicID: String, _contributorID: String, callback: Function): void {
        var db = this.mongoose.connection;
        var comicCellModel = ComicCell.comicCell;

        // get one comic cell to retrieve the ownerID of that cell. Assume same ownerID for the same ComicID
        comicCellModel.findOne({ 'comicID': _comicID }, function (err, doc) {
            if (err)
                return console.error(err);
            var ownerID = doc.ownerID;
                   
            // can delete only if the contributor is the OWNER of the COMIC
            if (_contributorID == ownerID) {
                comicCellModel.remove({ 'comicID': _comicID }, function (err, doc) {
                    if (err)
                        return console.error(err);
                    callback();
                });
            } else {
                console.log("User not authorized to delete comic cells.");
            }
        });
    }

    getRepresentativeImagesBody(comicIDs: any, index: any, comicCellIDArr: any, callback: Function): void {
        this.getRepresentative(comicIDs[index], (doc: any): void => {
            comicCellIDArr.push(doc._id);
            if (index == comicIDs.length - 1)
                callback(comicCellIDArr);
            else
                this.getRepresentativeImagesBody(comicIDs, index + 1, comicCellIDArr, callback);
        });
    }

    // given a list of comic IDs, return a list of image links each associated with the respective comicID 
    getRepresentativeImages(comicIDs: any, callback: Function): any {
        var db = this.mongoose.connection;
        var comicCellModel = ComicCell.comicCell;
        var comicCellIDArr = new Array<String>();

        this.getRepresentativeImagesBody(comicIDs, 0, comicCellIDArr, callback);
    }
}